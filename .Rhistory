df[[paste0(temp_var, "_rank")]] <- apply(df[,c("wind_speed_of_gust", paste0(temp_var, "_", ens_vec))], 1,
function(x){ rank(x, ties = "random")[1] })
# Frequency of bins
rh <- sapply(1:(n_ens+1), function(i){
sum(i == df[[paste0(temp_var, "_rank")]]) })
# Plot histogram via barplot
barplot(height = rh/sum(rh), # Frequencies
ylim = c(0, 0.4),
main = temp_var,
xlab = "Rank",
names.arg = 1:(n_ens + 1),
space = 0)
# Indicating calibration
abline(h = 1/(length(ens_vec) + 1),
lty = 2,
col = "grey")
}
# Path to Github repository functions
git_path <- "C:/Users/schulz/Documents/GitHub/CIENS/"
# Path to Github repository functions
git_path <- "C:/Users/schulz/Documents/GitHub/CIENS/"
# Set working directory
setwd(git_path)
# Initiate
source(file = paste0(getwd(), "/example_initiation.R"))
# Define period of initialization times
tm_vec <- init_vec[(year(init_vec) == 2015) | (year(init_vec) == 2016)]
# Define variables of interest including spatial variable
met_vars <- c("VMAX_10M", "VMAX_10M_MS", "T_2M")
obs_vars <- c("wind_speed_of_gust", "air_temperature")
# Get locations of interest:
# Karlsruhe-Rheinstetten (10731)
# Offenbach-Wetterpark (10641)
loc_vec <- loc_data$station_id[is.element(loc_data$station_id, c("10731", "10641"))]
# Generate data frame for multiple initialization times
df <- bind_rows(lapply(tm_vec, function(x) get_init(tm = x,
dir_path = data_path,
met_vars = met_vars,
obs_vars = obs_vars,
location_vec = loc_vec,
step_vec = c(12:14),
ens_vec = ens_vec)))
# Calculate ensemble mean and standard deviation for each entry
df[[paste0(temp_var, "_mean")]] <- rowMeans(df[,paste0(temp_var, "_", ens_vec)])
# For-Loop over meteorological variables
for(temp_var in met_vars){
# Calculate ensemble mean and standard deviation for each entry
df[[paste0(temp_var, "_mean")]] <- rowMeans(df[,paste0(temp_var, "_", ens_vec)])
df[[paste0(temp_var, "_sd")]] <- apply(df[,paste0(temp_var, "_", ens_vec)], 1, sd)
}
# Calculate CRPS values of station forecast and spatial forecast
crps_wg <- crps_sample(y = df[,"wind_speed_of_gust"],
dat = as.matrix(df[,paste0("VMAX_10M_", 1:n_ens)]))
crps_t2m <- crps_sample(y = df[,"air_temperature"],
dat = as.matrix(df[,paste0("T_2M", 1:n_ens)]))
# Calculate CRPS values of station forecast and spatial forecast
crps_wg <- crps_sample(y = df[,"wind_speed_of_gust"],
dat = as.matrix(df[,paste0("VMAX_10M_", 1:n_ens)]))
crps_t2m <- crps_sample(y = df[,"air_temperature"],
dat = as.matrix(df[,paste0("T_2M", 1:n_ens)]))
# Calculate CRPS values of station forecast and spatial forecast
crps_wg <- crps_sample(y = df[,"wind_speed_of_gust"],
dat = as.matrix(df[,paste0("VMAX_10M_", 1:n_ens)]))
# For-Loop over meteorological variables
for(temp_var in met_vars){
# Calculate ensemble mean and standard deviation for each entry
df[[paste0(temp_var, "_mean")]] <- rowMeans(df[,paste0(temp_var, "_", ens_vec)])
df[[paste0(temp_var, "_sd")]] <- apply(df[,paste0(temp_var, "_", ens_vec)], 1, sd)
}
# Calculate CRPS values of station forecast and spatial forecast
crps_wg <- crps_sample(y = df[,"wind_speed_of_gust"],
dat = as.matrix(df[,paste0("VMAX_10M_", 1:n_ens)]))
summary(as.matrix(df[,paste0("VMAX_10M_", 1:n_ens)]))
summary(df[,"wind_speed_of_gust"])
# OMit missing values
df <- na.omit(df)
# For-Loop over meteorological variables
for(temp_var in met_vars){
# Calculate ensemble mean and standard deviation for each entry
df[[paste0(temp_var, "_mean")]] <- rowMeans(df[,paste0(temp_var, "_", ens_vec)])
df[[paste0(temp_var, "_sd")]] <- apply(df[,paste0(temp_var, "_", ens_vec)], 1, sd)
}
# Calculate CRPS values of station forecast and spatial forecast
crps_wg <- crps_sample(y = df[,"wind_speed_of_gust"],
dat = as.matrix(df[,paste0("VMAX_10M_", 1:n_ens)]))
crps_t2m <- crps_sample(y = df[,"air_temperature"],
dat = as.matrix(df[,paste0("T_2M", 1:n_ens)]))
crps_t2m <- crps_sample(y = df[,"air_temperature"],
dat = as.matrix(df[,paste0("T_2M_", 1:n_ens)]))
# Summary of results
summary(data.frame("wg" = crps_wg, "t2m" = crps_t2m,
"wg_sd" = df[["VMAX_10M_sd"]], "wg_t2m" = df[["T_2M_sd"]]))
# Summary of results
summary(data.frame("wg_crps" = crps_wg, "t2m_crps" = crps_t2m,
"wg_sd" = df[["VMAX_10M_sd"]], "wg_t2m" = df[["T_2M_sd"]]))
# Plot verification rank histograms for both variables
par(mfrow = c(1, 2))
# For-Loop over observational variables
for(temp_var in obs_vars){
# Get name of corresponding forecast variable
if(temp_var == "wind_speed_of_gust"){ fc_var <- "VMAX_10M" }
else if(temp_var == "air_temperature"){ fc_var <- "T_2M" }
# Calculate ranks
df[[paste0(temp_var, "_rank")]] <- apply(df[,c(temp_var, paste0(fc_var, "_", ens_vec))], 1,
function(x){ rank(x, ties = "random")[1] })
# Frequency of bins
rh <- sapply(1:(n_ens+1), function(i){
sum(i == df[[paste0(temp_var, "_rank")]]) })
# Plot histogram via barplot
barplot(height = rh/sum(rh), # Frequencies
main = temp_var,
xlab = "Rank",
names.arg = 1:(n_ens + 1),
space = 0)
# Indicating calibration
abline(h = 1/(length(ens_vec) + 1),
lty = 2,
col = "grey")
}
### Postprocessing via EMOS ###
# Consider only Karlsruhe and 12 hour
df_ka <- subset(df, (location == "10731") & (step == 12))
## Temperature postprocessing
# Train EMOS model using wind gust ensemble predictions
tp_emos_train <- emos_est(train = df_ka[i_train,],
loc_pred = "T_2M_mean",
scale_pred = "VMAX_10M_mean", # Use gusts as predictor
target = "air_temperature",
distr = "norm")
# Show EMOS output (Consider parameterization!)
print(tp_emos_train)
# Train EMOS model using wind gust ensemble predictions
tp_emos_pred <- emos_pred(X = df_ka[i_test,],
loc_pred = "T_2M_mean",
scale_pred = "VMAX_10M_mean",
target = "air_temperature",
distr = "norm",
par_emos = tp_emos_train$par)
# Ensemble CRPS for Karlsruhe
crps_ens <- crps_sample(y = df_ka[i_test, "air_temperature"],
dat = as.matrix(df_ka[i_test, paste0("T_2M_", 1:n_ens)]))
# Skill
print(1 - mean(tp_emos_pred$scores$crps)/mean(crps_ens))
# Skill
print(100*round(1 - mean(tp_emos_pred$scores$crps)/mean(crps_ens), 4)
)
# Generate PIT histograms
hist(tp_emos_pred$scores$pit,
freq = FALSE,
xlab = "PIT",
main = "EMOS, temperature: Karlsruhe")
# Indicating calibration
abline(h = 1,
lty = 2,
col = "grey")
# Summary of CRPS
summary(data.frame("Ensemble" = crps_ens,
"EMOS" = tp_emos_pred$scores$crps))
# Summary of CRPS
boxplot(crps_ens- tp_emos_pred$scores$crps)
# Equal performance
abline(h = 0,
lty = 2,
col = "grey")
# Path to Github repository functions
git_path <- "C:/Users/schulz/Documents/GitHub/CIENS/"
# Set working directory
setwd(git_path)
# Initiate
source(file = paste0(getwd(), "/init_file.R"))
# Restrict to initialization times at 00 UTC
tm_vec <- init_vec[hour(init_vec) == 00]
# Define period of initialization times
tm_vec <- tm_vec[(year(tm_vec) == 2015) | (year(tm_vec) == 2016)]
# Define variables of interest
met_vars <- c("VMAX_10M")
obs_vars <- c("wind_speed_of_gust")
# Get locations of interest:
# Karlsruhe-Rheinstetten (10731)
# Offenbach-Wetterpark (10641)
loc_vec <- loc_data$station_id[is.element(loc_data$station_id, c("10731", "10641"))]
# Generate data frame for multiple initialization times
df <- bind_rows(lapply(tm_vec, function(x) get_init(tm = x,
dir_path = data_path,
met_vars = met_vars,
obs_vars = obs_vars,
location_vec = loc_vec,
step_vec = c(12:13),
ens_vec = ens_vec)))
# Calculate ensemble mean and standard deviation for each entry
df[["VMAX_10M_mean"]] <- rowMeans(df[,paste0("VMAX_10M_", ens_vec)])
df[["VMAX_10M_sd"]] <- apply(df[,paste0("VMAX_10M_", ens_vec)], 1, sd)
#### Generate verification rank histograms ####
# Plot histograms for both stations and variables
par(mfrow = c(1, 2))
# Calculate ranks
df[["wind_speed_of_gust_rank"]] <- apply(df[,c("wind_speed_of_gust", paste0("VMAX_10M_", ens_vec))], 1,
function(x){ rank(x, ties = "random")[1] })
# For-Loop over locations
for(temp_loc in loc_vec){
# Frequency of bins
rh <- sapply(1:(n_ens+1), function(i){
sum(i == subset(df, location == temp_loc)[["wind_speed_of_gust_rank"]]) })
# Plot histogram via barplot
barplot(height = rh/sum(rh), # Frequencies
main = paste0("wind_speed_of_gust: ", temp_loc),
xlab = "Rank",
names.arg = 1:(n_ens + 1),
space = 0)
# Indicating calibration
abline(h = 1/(length(ens_vec) + 1),
lty = 2,
col = "grey")
}
#### Postprocessing via EMOS ####
# Load EMOS functions
source(file = paste0(git_path, "functions_emos.R"))
# Consider only Karlsruhe and 12 hour
df_ka <- subset(df, (location == "10731") & (step == 12))
# Split in training (2015) and test period (2016)
i_train <- which(year(df_ka[["init_tm"]]) == 2015)
i_test <- which(year(df_ka[["init_tm"]]) == 2016)
# Ensemble CRPS for Karlsruhe
crps_ens <- crps_sample(y = df_ka[i_test, "wind_speed_of_gust"],
dat = as.matrix(df_ka[i_test, paste0("VMAX_10M_", 1:n_ens)]))
# Train EMOS model using wind gust ensemble predictions
wg_emos_train <- emos_est(train = df_ka[i_train,],
loc_pred = "VMAX_10M_mean",
scale_pred = "VMAX_10M_sd",
target = "wind_speed_of_gust",
distr = "tlogis")
# Show EMOS output (Consider parameterization!)
print(wg_emos_train)
# Train EMOS model using wind gust ensemble predictions
wg_emos_pred <- emos_pred(X = df_ka[i_test,],
loc_pred = "VMAX_10M_mean",
scale_pred = "VMAX_10M_sd",
target = "wind_speed_of_gust",
distr = "tlogis",
par_emos = wg_emos_train$par)
# Summary of CRPS
summary(data.frame("Ensemble" = crps_ens,
"EMOS" = wg_emos_pred$scores$crps))
# Summary of CRPS
summary(data.frame("Ensemble CRPS" = crps_ens,
"EMOS CRPS" = wg_emos_pred$scores$crps))
# Skill score in percentage
print(round(100*(1 - mean(wg_emos_pred$scores$crps)/mean(crps_ens)), 2))
# Skill score in percentage
print(1 - mean(wg_emos_pred$scores$crps)/mean(crps_ens))
# Plot only PIT histogram
par(mfrow = c(1, 1))
# Generate PIT histograms
hist(wg_emos_pred$scores$pit,
freq = FALSE,
xlab = "PIT",
main = "EMOS, gusts: Karlsruhe")
# Indicating calibration
abline(h = 1,
lty = 2,
col = "grey")
#### Initialization ####
# Path to Github repository functions
git_path <- "C:/Users/schulz/Documents/GitHub/CIENS/"
# Set working directory
setwd(git_path)
# Initiate
source(file = paste0(getwd(), "/init_file.R"))
#### Get data ####
# Define period of initialization times
tm_vec <- init_vec[(year(init_vec) == 2015) | (year(init_vec) == 2016)]
# Define variables of interest including spatial variable
met_vars <- c("VMAX_10M", "VMAX_10M_MS", "T_2M")
obs_vars <- c("wind_speed_of_gust", "air_temperature")
# Get locations of interest:
# Karlsruhe-Rheinstetten (10731)
# Offenbach-Wetterpark (10641)
loc_vec <- loc_data$station_id[is.element(loc_data$station_id, c("10731", "10641"))]
# Generate data frame for multiple initialization times
df <- bind_rows(lapply(tm_vec, function(x) get_init(tm = x,
dir_path = data_path,
met_vars = met_vars,
obs_vars = obs_vars,
location_vec = loc_vec,
step_vec = c(12:14),
ens_vec = ens_vec)))
# Omit missing values
df <- na.omit(df)
# For-Loop over meteorological variables
for(temp_var in met_vars){
# Calculate ensemble mean and standard deviation for each entry
df[[paste0(temp_var, "_mean")]] <- rowMeans(df[,paste0(temp_var, "_", ens_vec)])
df[[paste0(temp_var, "_sd")]] <- apply(df[,paste0(temp_var, "_", ens_vec)], 1, sd)
}
#### Calculate scores ####
# Calculate CRPS values of station forecast and spatial forecast
crps_wg <- crps_sample(y = df[,"wind_speed_of_gust"],
dat = as.matrix(df[,paste0("VMAX_10M_", 1:n_ens)]))
crps_t2m <- crps_sample(y = df[,"air_temperature"],
dat = as.matrix(df[,paste0("T_2M_", 1:n_ens)]))
# Summary of results
summary(data.frame("wg_crps" = crps_wg, "t2m_crps" = crps_t2m,
"wg_sd" = df[["VMAX_10M_sd"]], "wg_t2m" = df[["T_2M_sd"]]))
#### Generate verification rank histograms ####
# Plot verification rank histograms for both variables
par(mfrow = c(1, 2))
# For-Loop over observational variables
for(temp_var in obs_vars){
# Get name of corresponding forecast variable
if(temp_var == "wind_speed_of_gust"){ fc_var <- "VMAX_10M" }
else if(temp_var == "air_temperature"){ fc_var <- "T_2M" }
# Calculate ranks
df[[paste0(temp_var, "_rank")]] <- apply(df[,c(temp_var, paste0(fc_var, "_", ens_vec))], 1,
function(x){ rank(x, ties = "random")[1] })
# Frequency of bins
rh <- sapply(1:(n_ens+1), function(i){
sum(i == df[[paste0(temp_var, "_rank")]]) })
# Plot histogram via barplot
barplot(height = rh/sum(rh), # Frequencies
main = temp_var,
xlab = "Rank",
names.arg = 1:(n_ens + 1),
space = 0)
# Indicating calibration
abline(h = 1/(length(ens_vec) + 1),
lty = 2,
col = "grey")
}
#### Postprocessing via EMOS ####
# Consider only Karlsruhe and 12 hour
df_ka <- subset(df, (location == "10731") & (step == 12))
## Temperature postprocessing
# Train EMOS model using wind gust ensemble predictions
tp_emos_train <- emos_est(train = df_ka[i_train,],
loc_pred = "T_2M_mean",
scale_pred = "VMAX_10M_mean", # Use gusts as predictor for scale
target = "air_temperature",
distr = "norm")
#### Postprocessing via EMOS ####
# Load EMOS functions
source(file = paste0(git_path, "functions_emos.R"))
## Temperature postprocessing
# Train EMOS model using wind gust ensemble predictions
tp_emos_train <- emos_est(train = df_ka[i_train,],
loc_pred = "T_2M_mean",
scale_pred = "VMAX_10M_mean", # Use gusts as predictor for scale
target = "air_temperature",
distr = "norm")
## Temperature postprocessing
# Train EMOS model using temperature and wind gust predictions
tp_emos_train <- emos_est(train = df_ka[i_train,],
loc_pred = "T_2M_mean",
scale_pred = "VMAX_10M_mean", # Use gusts as predictor for scale
target = "air_temperature",
distr = "norm")
# Split in training (2015) and test period (2016)
i_train <- which(year(df_ka[["init_tm"]]) == 2015)
i_test <- which(year(df_ka[["init_tm"]]) == 2016)
## Temperature postprocessing
# Train EMOS model using temperature and wind gust predictions
tp_emos_train <- emos_est(train = df_ka[i_train,],
loc_pred = "T_2M_mean",
scale_pred = "VMAX_10M_mean", # Use gusts as predictor for scale
target = "air_temperature",
distr = "norm")
# Show EMOS output (Consider parameterization!)
print(tp_emos_train)
# Train EMOS model using wind gust ensemble predictions
tp_emos_pred <- emos_pred(X = df_ka[i_test,],
loc_pred = "T_2M_mean",
scale_pred = "VMAX_10M_mean",
target = "air_temperature",
distr = "norm",
par_emos = tp_emos_train$par)
# Ensemble CRPS for Karlsruhe
crps_ens <- crps_sample(y = df_ka[i_test, "air_temperature"],
dat = as.matrix(df_ka[i_test, paste0("T_2M_", 1:n_ens)]))
# Summary of CRPS via boxplot of differences
boxplot(crps_ens- tp_emos_pred$scores$crps)
# Equal performance
abline(h = 0,
lty = 2,
col = "grey")
# Skill in percentage
print(1 - mean(tp_emos_pred$scores$crps)/mean(crps_ens))
# Generate PIT histograms
hist(tp_emos_pred$scores$pit,
freq = FALSE,
xlab = "PIT",
main = "EMOS, temperature: Karlsruhe")
# Indicating calibration
abline(h = 1,
lty = 2,
col = "grey")
#### Initialization ####
# Path to Github repository functions
git_path <- "C:/Users/schulz/Documents/GitHub/CIENS/"
# Set working directory
setwd(git_path)
# Initiate
source(file = paste0(getwd(), "/init_file.R"))
#### Get data ####
# Restrict to initialization times at 00 UTC
tm_vec <- init_vec[hour(init_vec) == 00]
# Define period of initialization times
tm_vec <- tm_vec[year(tm_vec) == 2019]
# Define variables of interest including spatial variable
met_vars <- c("VMAX_10M", "VMAX_10M_MS")
obs_vars <- c("wind_speed_of_gust")
# Get locations of interest:
# Karlsruhe-Rheinstetten (10731)
# Offenbach-Wetterpark (10641)
loc_vec <- loc_data$station_id[is.element(loc_data$station_id, c("10731", "10641"))]
# Generate data frame for multiple initialization times
df <- bind_rows(lapply(tm_vec, function(x) get_init(tm = x,
dir_path = data_path,
met_vars = met_vars,
obs_vars = obs_vars,
location_vec = loc_vec,
step_vec = c(18:21),
ens_vec = ens_vec)))
# For-Loop over meteorological variables
for(temp_var in met_vars){
# Calculate ensemble mean and standard deviation for each entry
df[[paste0(temp_var, "_mean")]] <- rowMeans(df[,paste0(temp_var, "_", ens_vec)])
df[[paste0(temp_var, "_sd")]] <- apply(df[,paste0(temp_var, "_", ens_vec)], 1, sd)
}
#### Calculate scores ####
# Calculate CRPS values of station forecast and spatial forecast
crps0 <- crps_sample(y = df[,"wind_speed_of_gust"],
dat = as.matrix(df[,paste0("VMAX_10M_", 1:n_ens)]))
crps_spatial <- crps_sample(y = df[,"wind_speed_of_gust"],
dat = as.matrix(df[,paste0("VMAX_10M_MS_", 1:n_ens)]))
# Summary of results
df_eval <- data.frame("crps_local" = crps0, "crps_spatial" = crps_spatial,
"ens_sd_local" = df[["VMAX_10M_sd"]], "ens_sd_spatial" = df[["VMAX_10M_MS_sd"]])
# Boxplots without outliers
boxplot(df_eval, outline = FALSE)
#### Generate verification rank histograms ####
# Plot histograms for both stations and variables
par(mfrow = c(1, 2))
# For-Loop over observational variables
for(temp_var in met_vars){
# Calculate ranks
df[[paste0(temp_var, "_rank")]] <- apply(df[,c("wind_speed_of_gust", paste0(temp_var, "_", ens_vec))], 1,
function(x){ rank(x, ties = "random")[1] })
# Frequency of bins
rh <- sapply(1:(n_ens+1), function(i){
sum(i == df[[paste0(temp_var, "_rank")]]) })
# Plot histogram via barplot
barplot(height = rh/sum(rh), # Frequencies
ylim = c(0, 0.4),
main = temp_var,
xlab = "Rank",
names.arg = 1:(n_ens + 1),
space = 0)
# Indicating calibration
abline(h = 1/(length(ens_vec) + 1),
lty = 2,
col = "grey")
}
# Summary of results
df_eval <- data.frame("crps_local" = crps0, "crps_spatial" = crps_spatial,
"crps_diff" = crps0 - crps_spatial,
"ens_sd_local" = df[["VMAX_10M_sd"]], "ens_sd_spatial" = df[["VMAX_10M_MS_sd"]],
"crps_diff" = df[["VMAX_10M_sd"]] - df[["VMAX_10M_MS_sd"]])
# Boxplots without outliers
boxplot(df_eval, outline = FALSE)
# Plot boxplot
par(mfrow = c(1, 1))
# Boxplots without outliers
boxplot(df_eval, outline = FALSE)
# Equal values
abline(h = 0,
lty = 2,
col = "grey")
# Summary of results
df_eval <- data.frame("crps_local" = crps0, "crps_spatial" = crps_spatial,
"crps_diff" = crps0 - crps_spatial,
"ens_sd_local" = df[["VMAX_10M_sd"]], "ens_sd_spatial" = df[["VMAX_10M_MS_sd"]],
"ens_sd_diff" = df[["VMAX_10M_sd"]] - df[["VMAX_10M_MS_sd"]])
# Plot boxplot
par(mfrow = c(1, 1))
# Boxplots without outliers
boxplot(df_eval, outline = FALSE)
# Equal values
abline(h = 0,
lty = 2,
col = "grey")
#### Generate verification rank histograms ####
# Plot histograms for both stations and variables
par(mfrow = c(1, 2))
# For-Loop over observational variables
for(temp_var in met_vars){
# Calculate ranks
df[[paste0(temp_var, "_rank")]] <- apply(df[,c("wind_speed_of_gust", paste0(temp_var, "_", ens_vec))], 1,
function(x){ rank(x, ties = "random")[1] })
# Frequency of bins
rh <- sapply(1:(n_ens+1), function(i){
sum(i == df[[paste0(temp_var, "_rank")]]) })
# Plot histogram via barplot
barplot(height = rh/sum(rh), # Frequencies
ylim = c(0, 0.4),
main = temp_var,
xlab = "Rank",
names.arg = 1:(n_ens + 1),
space = 0)
# Indicating calibration
abline(h = 1/(length(ens_vec) + 1),
lty = 2,
col = "grey")
}
